{"ast":null,"code":"export function normalizeParams(...params) {\n  let bindParams = params.length > 1 ? params : params[0];\n  if (bindParams == null) {\n    bindParams = [];\n  }\n  if (typeof bindParams !== 'object' || bindParams instanceof ArrayBuffer || ArrayBuffer.isView(bindParams)) {\n    bindParams = [bindParams];\n  }\n  const shouldPassAsArray = Array.isArray(bindParams);\n  if (Array.isArray(bindParams)) {\n    bindParams = bindParams.reduce((acc, value, index) => {\n      acc[index] = value;\n      return acc;\n    }, {});\n  }\n  const primitiveParams = {};\n  const blobParams = {};\n  for (const key in bindParams) {\n    const value = bindParams[key];\n    if (value instanceof Uint8Array) {\n      blobParams[key] = value;\n    } else {\n      primitiveParams[key] = value;\n    }\n  }\n  return [primitiveParams, blobParams, shouldPassAsArray];\n}\nexport function composeRow(columnNames, columnValues) {\n  const row = {};\n  if (columnNames.length !== columnValues.length) {\n    throw new Error(`Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValues.length}`);\n  }\n  for (let i = 0; i < columnNames.length; i++) {\n    row[columnNames[i]] = columnValues[i];\n  }\n  return row;\n}\nexport function composeRows(columnNames, columnValuesList) {\n  if (columnValuesList.length === 0) {\n    return [];\n  }\n  if (columnNames.length !== columnValuesList[0].length) {\n    throw new Error(`Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValuesList[0].length}`);\n  }\n  const results = [];\n  for (const columnValues of columnValuesList) {\n    const row = {};\n    for (let i = 0; i < columnNames.length; i++) {\n      row[columnNames[i]] = columnValues[i];\n    }\n    results.push(row);\n  }\n  return results;\n}","map":{"version":3,"names":["normalizeParams","params","bindParams","length","ArrayBuffer","isView","shouldPassAsArray","Array","isArray","reduce","acc","value","index","primitiveParams","blobParams","key","Uint8Array","composeRow","columnNames","columnValues","row","Error","i","composeRows","columnValuesList","results","push"],"sources":["C:\\Users\\Tyler\\Downloads\\PrecisionTracker-v4-wired\\PrecisionTracker\\mobile\\node_modules\\expo-sqlite\\src\\paramUtils.ts"],"sourcesContent":["import {\n  SQLiteBindBlobParams,\n  SQLiteBindParams,\n  SQLiteBindPrimitiveParams,\n  SQLiteBindValue,\n  type SQLiteColumnNames,\n  type SQLiteColumnValues,\n} from './NativeStatement';\n\n/**\n * Normalize the bind params to data structure that can be passed to native module.\n * The data structure is a tuple of [primitiveParams, blobParams, shouldPassAsArray].\n * @hidden\n */\nexport function normalizeParams(\n  ...params: any[]\n): [SQLiteBindPrimitiveParams, SQLiteBindBlobParams, boolean] {\n  let bindParams = params.length > 1 ? params : (params[0] as SQLiteBindParams);\n  if (bindParams == null) {\n    bindParams = [];\n  }\n  if (\n    typeof bindParams !== 'object' ||\n    bindParams instanceof ArrayBuffer ||\n    ArrayBuffer.isView(bindParams)\n  ) {\n    bindParams = [bindParams];\n  }\n  const shouldPassAsArray = Array.isArray(bindParams);\n  if (Array.isArray(bindParams)) {\n    bindParams = bindParams.reduce<Record<string, SQLiteBindValue>>((acc, value, index) => {\n      acc[index] = value;\n      return acc;\n    }, {});\n  }\n\n  const primitiveParams: SQLiteBindPrimitiveParams = {};\n  const blobParams: SQLiteBindBlobParams = {};\n  for (const key in bindParams) {\n    const value = bindParams[key];\n    if (value instanceof Uint8Array) {\n      blobParams[key] = value;\n    } else {\n      primitiveParams[key] = value;\n    }\n  }\n\n  return [primitiveParams, blobParams, shouldPassAsArray];\n}\n\n/**\n * Compose `columnNames` and `columnValues` to an row object.\n * @hidden\n */\nexport function composeRow<T>(columnNames: SQLiteColumnNames, columnValues: SQLiteColumnValues): T {\n  const row = {};\n  if (columnNames.length !== columnValues.length) {\n    throw new Error(\n      `Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValues.length}`\n    );\n  }\n  for (let i = 0; i < columnNames.length; i++) {\n    row[columnNames[i]] = columnValues[i];\n  }\n  return row as T;\n}\n\n/**\n * Compose `columnNames` and `columnValuesList` to an array of row objects.\n * @hidden\n */\nexport function composeRows<T>(\n  columnNames: SQLiteColumnNames,\n  columnValuesList: SQLiteColumnValues[]\n): T[] {\n  if (columnValuesList.length === 0) {\n    return [];\n  }\n  if (columnNames.length !== columnValuesList[0].length) {\n    // We only check the first row because SQLite returns the same column count for all rows.\n    throw new Error(\n      `Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValuesList[0].length}`\n    );\n  }\n  const results: T[] = [];\n  for (const columnValues of columnValuesList) {\n    const row = {};\n    for (let i = 0; i < columnNames.length; i++) {\n      row[columnNames[i]] = columnValues[i];\n    }\n    results.push(row as T);\n  }\n  return results;\n}\n"],"mappings":"AAcA,OAAM,SAAUA,eAAeA,CAC7B,GAAGC,MAAa;EAEhB,IAAIC,UAAU,GAAGD,MAAM,CAACE,MAAM,GAAG,CAAC,GAAGF,MAAM,GAAIA,MAAM,CAAC,CAAC,CAAsB;EAC7E,IAAIC,UAAU,IAAI,IAAI,EAAE;IACtBA,UAAU,GAAG,EAAE;;EAEjB,IACE,OAAOA,UAAU,KAAK,QAAQ,IAC9BA,UAAU,YAAYE,WAAW,IACjCA,WAAW,CAACC,MAAM,CAACH,UAAU,CAAC,EAC9B;IACAA,UAAU,GAAG,CAACA,UAAU,CAAC;;EAE3B,MAAMI,iBAAiB,GAAGC,KAAK,CAACC,OAAO,CAACN,UAAU,CAAC;EACnD,IAAIK,KAAK,CAACC,OAAO,CAACN,UAAU,CAAC,EAAE;IAC7BA,UAAU,GAAGA,UAAU,CAACO,MAAM,CAAkC,CAACC,GAAG,EAAEC,KAAK,EAAEC,KAAK,KAAI;MACpFF,GAAG,CAACE,KAAK,CAAC,GAAGD,KAAK;MAClB,OAAOD,GAAG;IACZ,CAAC,EAAE,EAAE,CAAC;;EAGR,MAAMG,eAAe,GAA8B,EAAE;EACrD,MAAMC,UAAU,GAAyB,EAAE;EAC3C,KAAK,MAAMC,GAAG,IAAIb,UAAU,EAAE;IAC5B,MAAMS,KAAK,GAAGT,UAAU,CAACa,GAAG,CAAC;IAC7B,IAAIJ,KAAK,YAAYK,UAAU,EAAE;MAC/BF,UAAU,CAACC,GAAG,CAAC,GAAGJ,KAAK;KACxB,MAAM;MACLE,eAAe,CAACE,GAAG,CAAC,GAAGJ,KAAK;;;EAIhC,OAAO,CAACE,eAAe,EAAEC,UAAU,EAAER,iBAAiB,CAAC;AACzD;AAMA,OAAM,SAAUW,UAAUA,CAAIC,WAA8B,EAAEC,YAAgC;EAC5F,MAAMC,GAAG,GAAG,EAAE;EACd,IAAIF,WAAW,CAACf,MAAM,KAAKgB,YAAY,CAAChB,MAAM,EAAE;IAC9C,MAAM,IAAIkB,KAAK,CACb,kDAAkDH,WAAW,CAACf,MAAM,aAAagB,YAAY,CAAChB,MAAM,EAAE,CACvG;;EAEH,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACf,MAAM,EAAEmB,CAAC,EAAE,EAAE;IAC3CF,GAAG,CAACF,WAAW,CAACI,CAAC,CAAC,CAAC,GAAGH,YAAY,CAACG,CAAC,CAAC;;EAEvC,OAAOF,GAAQ;AACjB;AAMA,OAAM,SAAUG,WAAWA,CACzBL,WAA8B,EAC9BM,gBAAsC;EAEtC,IAAIA,gBAAgB,CAACrB,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO,EAAE;;EAEX,IAAIe,WAAW,CAACf,MAAM,KAAKqB,gBAAgB,CAAC,CAAC,CAAC,CAACrB,MAAM,EAAE;IAErD,MAAM,IAAIkB,KAAK,CACb,kDAAkDH,WAAW,CAACf,MAAM,aAAaqB,gBAAgB,CAAC,CAAC,CAAC,CAACrB,MAAM,EAAE,CAC9G;;EAEH,MAAMsB,OAAO,GAAQ,EAAE;EACvB,KAAK,MAAMN,YAAY,IAAIK,gBAAgB,EAAE;IAC3C,MAAMJ,GAAG,GAAG,EAAE;IACd,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACf,MAAM,EAAEmB,CAAC,EAAE,EAAE;MAC3CF,GAAG,CAACF,WAAW,CAACI,CAAC,CAAC,CAAC,GAAGH,YAAY,CAACG,CAAC,CAAC;;IAEvCG,OAAO,CAACC,IAAI,CAACN,GAAQ,CAAC;;EAExB,OAAOK,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}