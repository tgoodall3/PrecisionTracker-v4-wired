{"ast":null,"code":"import { EventEmitter } from 'expo-modules-core';\nimport ExpoSQLite from './ExpoSQLiteNext';\nimport { SQLiteStatement } from './SQLiteStatement';\nconst emitter = new EventEmitter(ExpoSQLite);\nexport class SQLiteDatabase {\n  constructor(databaseName, options, nativeDatabase) {\n    this.databaseName = databaseName;\n    this.options = options;\n    this.nativeDatabase = nativeDatabase;\n  }\n  isInTransactionAsync() {\n    return this.nativeDatabase.isInTransactionAsync();\n  }\n  closeAsync() {\n    return this.nativeDatabase.closeAsync();\n  }\n  execAsync(source) {\n    return this.nativeDatabase.execAsync(source);\n  }\n  serializeAsync(databaseName = 'main') {\n    return this.nativeDatabase.serializeAsync(databaseName);\n  }\n  async prepareAsync(source) {\n    const nativeStatement = new ExpoSQLite.NativeStatement();\n    await this.nativeDatabase.prepareAsync(nativeStatement, source);\n    return new SQLiteStatement(this.nativeDatabase, nativeStatement);\n  }\n  async withTransactionAsync(task) {\n    try {\n      await this.execAsync('BEGIN');\n      await task();\n      await this.execAsync('COMMIT');\n    } catch (e) {\n      await this.execAsync('ROLLBACK');\n      throw e;\n    }\n  }\n  async withExclusiveTransactionAsync(task) {\n    const transaction = await Transaction.createAsync(this);\n    let error;\n    try {\n      await transaction.execAsync('BEGIN');\n      await task(transaction);\n      await transaction.execAsync('COMMIT');\n    } catch (e) {\n      await transaction.execAsync('ROLLBACK');\n      error = e;\n    } finally {\n      await transaction.closeAsync();\n    }\n    if (error) {\n      throw error;\n    }\n  }\n  isInTransactionSync() {\n    return this.nativeDatabase.isInTransactionSync();\n  }\n  closeSync() {\n    return this.nativeDatabase.closeSync();\n  }\n  execSync(source) {\n    return this.nativeDatabase.execSync(source);\n  }\n  serializeSync(databaseName = 'main') {\n    return this.nativeDatabase.serializeSync(databaseName);\n  }\n  prepareSync(source) {\n    const nativeStatement = new ExpoSQLite.NativeStatement();\n    this.nativeDatabase.prepareSync(nativeStatement, source);\n    return new SQLiteStatement(this.nativeDatabase, nativeStatement);\n  }\n  withTransactionSync(task) {\n    try {\n      this.execSync('BEGIN');\n      task();\n      this.execSync('COMMIT');\n    } catch (e) {\n      this.execSync('ROLLBACK');\n      throw e;\n    }\n  }\n  async runAsync(source, ...params) {\n    const statement = await this.prepareAsync(source);\n    let result;\n    try {\n      result = await statement.executeAsync(...params);\n    } finally {\n      await statement.finalizeAsync();\n    }\n    return result;\n  }\n  async getFirstAsync(source, ...params) {\n    const statement = await this.prepareAsync(source);\n    let firstRow;\n    try {\n      const result = await statement.executeAsync(...params);\n      firstRow = await result.getFirstAsync();\n    } finally {\n      await statement.finalizeAsync();\n    }\n    return firstRow;\n  }\n  async *getEachAsync(source, ...params) {\n    const statement = await this.prepareAsync(source);\n    try {\n      const result = await statement.executeAsync(...params);\n      for await (const row of result) {\n        yield row;\n      }\n    } finally {\n      await statement.finalizeAsync();\n    }\n  }\n  async getAllAsync(source, ...params) {\n    const statement = await this.prepareAsync(source);\n    let allRows;\n    try {\n      const result = await statement.executeAsync(...params);\n      allRows = await result.getAllAsync();\n    } finally {\n      await statement.finalizeAsync();\n    }\n    return allRows;\n  }\n  runSync(source, ...params) {\n    const statement = this.prepareSync(source);\n    let result;\n    try {\n      result = statement.executeSync(...params);\n    } finally {\n      statement.finalizeSync();\n    }\n    return result;\n  }\n  getFirstSync(source, ...params) {\n    const statement = this.prepareSync(source);\n    let firstRow;\n    try {\n      const result = statement.executeSync(...params);\n      firstRow = result.getFirstSync();\n    } finally {\n      statement.finalizeSync();\n    }\n    return firstRow;\n  }\n  *getEachSync(source, ...params) {\n    const statement = this.prepareSync(source);\n    try {\n      const result = statement.executeSync(...params);\n      for (const row of result) {\n        yield row;\n      }\n    } finally {\n      statement.finalizeSync();\n    }\n  }\n  getAllSync(source, ...params) {\n    const statement = this.prepareSync(source);\n    let allRows;\n    try {\n      const result = statement.executeSync(...params);\n      allRows = result.getAllSync();\n    } finally {\n      statement.finalizeSync();\n    }\n    return allRows;\n  }\n}\nexport async function openDatabaseAsync(databaseName, options) {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(databaseName, openOptions);\n  await nativeDatabase.initAsync();\n  return new SQLiteDatabase(databaseName, openOptions, nativeDatabase);\n}\nexport function openDatabaseSync(databaseName, options) {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(databaseName, openOptions);\n  nativeDatabase.initSync();\n  return new SQLiteDatabase(databaseName, openOptions, nativeDatabase);\n}\nexport async function deserializeDatabaseAsync(serializedData, options) {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(':memory:', openOptions, serializedData);\n  await nativeDatabase.initAsync();\n  return new SQLiteDatabase(':memory:', openOptions, nativeDatabase);\n}\nexport function deserializeDatabaseSync(serializedData, options) {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(':memory:', openOptions, serializedData);\n  nativeDatabase.initSync();\n  return new SQLiteDatabase(':memory:', openOptions, nativeDatabase);\n}\nexport async function deleteDatabaseAsync(databaseName) {\n  return await ExpoSQLite.deleteDatabaseAsync(databaseName);\n}\nexport function deleteDatabaseSync(databaseName) {\n  return ExpoSQLite.deleteDatabaseSync(databaseName);\n}\nexport function addDatabaseChangeListener(listener) {\n  return emitter.addListener('onDatabaseChange', listener);\n}\nclass Transaction extends SQLiteDatabase {\n  static async createAsync(db) {\n    const options = Object.assign({}, db.options, {\n      useNewConnection: true\n    });\n    const nativeDatabase = new ExpoSQLite.NativeDatabase(db.databaseName, options);\n    await nativeDatabase.initAsync();\n    return new Transaction(db.databaseName, options, nativeDatabase);\n  }\n}","map":{"version":3,"names":["EventEmitter","ExpoSQLite","SQLiteStatement","emitter","SQLiteDatabase","constructor","databaseName","options","nativeDatabase","isInTransactionAsync","closeAsync","execAsync","source","serializeAsync","prepareAsync","nativeStatement","NativeStatement","withTransactionAsync","task","e","withExclusiveTransactionAsync","transaction","Transaction","createAsync","error","isInTransactionSync","closeSync","execSync","serializeSync","prepareSync","withTransactionSync","runAsync","params","statement","result","executeAsync","finalizeAsync","getFirstAsync","firstRow","getEachAsync","row","getAllAsync","allRows","runSync","executeSync","finalizeSync","getFirstSync","getEachSync","getAllSync","openDatabaseAsync","openOptions","NativeDatabase","initAsync","openDatabaseSync","initSync","deserializeDatabaseAsync","serializedData","deserializeDatabaseSync","deleteDatabaseAsync","deleteDatabaseSync","addDatabaseChangeListener","listener","addListener","db","Object","assign","useNewConnection"],"sources":["C:\\Users\\Tyler\\Downloads\\PrecisionTracker-v4-wired\\PrecisionTracker\\mobile\\node_modules\\expo-sqlite\\src\\SQLiteDatabase.ts"],"sourcesContent":["import { EventEmitter, Subscription } from 'expo-modules-core';\n\nimport ExpoSQLite from './ExpoSQLiteNext';\nimport { NativeDatabase, SQLiteOpenOptions } from './NativeDatabase';\nimport {\n  SQLiteBindParams,\n  SQLiteExecuteAsyncResult,\n  SQLiteExecuteSyncResult,\n  SQLiteRunResult,\n  SQLiteStatement,\n  SQLiteVariadicBindParams,\n} from './SQLiteStatement';\n\nexport { SQLiteOpenOptions };\n\nconst emitter = new EventEmitter(ExpoSQLite);\n\n/**\n * A SQLite database.\n */\nexport class SQLiteDatabase {\n  constructor(\n    public readonly databaseName: string,\n    public readonly options: SQLiteOpenOptions,\n    private readonly nativeDatabase: NativeDatabase\n  ) {}\n\n  /**\n   * Asynchronous call to return whether the database is currently in a transaction.\n   */\n  public isInTransactionAsync(): Promise<boolean> {\n    return this.nativeDatabase.isInTransactionAsync();\n  }\n\n  /**\n   * Close the database.\n   */\n  public closeAsync(): Promise<void> {\n    return this.nativeDatabase.closeAsync();\n  }\n\n  /**\n   * Execute all SQL queries in the supplied string.\n   * > Note: The queries are not escaped for you! Be careful when constructing your queries.\n   *\n   * @param source A string containing all the SQL queries.\n   */\n  public execAsync(source: string): Promise<void> {\n    return this.nativeDatabase.execAsync(source);\n  }\n\n  /**\n   * [Serialize the database](https://sqlite.org/c3ref/serialize.html) as `Uint8Array`.\n   *\n   * @param databaseName The name of the current attached databases. The default value is `main` which is the default database name.\n   */\n  public serializeAsync(databaseName: string = 'main'): Promise<Uint8Array> {\n    return this.nativeDatabase.serializeAsync(databaseName);\n  }\n\n  /**\n   * Create a [prepared SQLite statement](https://www.sqlite.org/c3ref/prepare.html).\n   *\n   * @param source A string containing the SQL query.\n   */\n  public async prepareAsync(source: string): Promise<SQLiteStatement> {\n    const nativeStatement = new ExpoSQLite.NativeStatement();\n    await this.nativeDatabase.prepareAsync(nativeStatement, source);\n    return new SQLiteStatement(this.nativeDatabase, nativeStatement);\n  }\n\n  /**\n   * Execute a transaction and automatically commit/rollback based on the `task` result.\n   *\n   * > **Note:** This transaction is not exclusive and can be interrupted by other async queries.\n   * @example\n   * ```ts\n   * db.withTransactionAsync(async () => {\n   *   await db.execAsync('UPDATE test SET name = \"aaa\"');\n   *\n   *   //\n   *   // We cannot control the order of async/await order, so order of execution is not guaranteed.\n   *   // The following UPDATE query out of transaction may be executed here and break the expectation.\n   *   //\n   *\n   *   const result = await db.getAsync<{ name: string }>('SELECT name FROM Users');\n   *   expect(result?.name).toBe('aaa');\n   * });\n   * db.execAsync('UPDATE test SET name = \"bbb\"');\n   * ```\n   * If you worry about the order of execution, use `withExclusiveTransactionAsync` instead.\n   *\n   * @param task An async function to execute within a transaction.\n   */\n  public async withTransactionAsync(task: () => Promise<void>): Promise<void> {\n    try {\n      await this.execAsync('BEGIN');\n      await task();\n      await this.execAsync('COMMIT');\n    } catch (e) {\n      await this.execAsync('ROLLBACK');\n      throw e;\n    }\n  }\n\n  /**\n   * Execute a transaction and automatically commit/rollback based on the `task` result.\n   *\n   * The transaction may be exclusive.\n   * As long as the transaction is converted into a write transaction,\n   * the other async write queries will abort with `database is locked` error.\n   *\n   * @param task An async function to execute within a transaction. Any queries inside the transaction must be executed on the `txn` object.\n   * The `txn` object has the same interfaces as the [`SQLiteDatabase`](#sqlitedatabase) object. You can use `txn` like a [`SQLiteDatabase`](#sqlitedatabase) object.\n   *\n   * @example\n   * ```ts\n   * db.withExclusiveTransactionAsync(async (txn) => {\n   *   await txn.execAsync('UPDATE test SET name = \"aaa\"');\n   * });\n   * ```\n   */\n  public async withExclusiveTransactionAsync(\n    task: (txn: Transaction) => Promise<void>\n  ): Promise<void> {\n    const transaction = await Transaction.createAsync(this);\n    let error;\n    try {\n      await transaction.execAsync('BEGIN');\n      await task(transaction);\n      await transaction.execAsync('COMMIT');\n    } catch (e) {\n      await transaction.execAsync('ROLLBACK');\n      error = e;\n    } finally {\n      await transaction.closeAsync();\n    }\n    if (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Synchronous call to return whether the database is currently in a transaction.\n   */\n  public isInTransactionSync(): boolean {\n    return this.nativeDatabase.isInTransactionSync();\n  }\n\n  /**\n   * Close the database.\n   */\n  public closeSync(): void {\n    return this.nativeDatabase.closeSync();\n  }\n\n  /**\n   * Execute all SQL queries in the supplied string.\n   *\n   * > **Note:** The queries are not escaped for you! Be careful when constructing your queries.\n   *\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   *\n   * @param source A string containing all the SQL queries.\n   */\n  public execSync(source: string): void {\n    return this.nativeDatabase.execSync(source);\n  }\n\n  /**\n   * [Serialize the database](https://sqlite.org/c3ref/serialize.html) as `Uint8Array`.\n   *\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   *\n   * @param databaseName The name of the current attached databases. The default value is `main` which is the default database name.\n   */\n  public serializeSync(databaseName: string = 'main'): Uint8Array {\n    return this.nativeDatabase.serializeSync(databaseName);\n  }\n\n  /**\n   * Create a [prepared SQLite statement](https://www.sqlite.org/c3ref/prepare.html).\n   *\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   *\n   * @param source A string containing the SQL query.\n   */\n  public prepareSync(source: string): SQLiteStatement {\n    const nativeStatement = new ExpoSQLite.NativeStatement();\n    this.nativeDatabase.prepareSync(nativeStatement, source);\n    return new SQLiteStatement(this.nativeDatabase, nativeStatement);\n  }\n\n  /**\n   * Execute a transaction and automatically commit/rollback based on the `task` result.\n   *\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   *\n   * @param task An async function to execute within a transaction.\n   */\n  public withTransactionSync(task: () => void): void {\n    try {\n      this.execSync('BEGIN');\n      task();\n      this.execSync('COMMIT');\n    } catch (e) {\n      this.execSync('ROLLBACK');\n      throw e;\n    }\n  }\n\n  //#region Statement API shorthands\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareAsync()`](#prepareasyncsource), [`SQLiteStatement.executeAsync()`](#executeasyncparams), and [`SQLiteStatement.finalizeAsync()`](#finalizeasync).\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   */\n  public runAsync(source: string, params: SQLiteBindParams): Promise<SQLiteRunResult>;\n\n  /**\n   * @hidden\n   */\n  public runAsync(source: string, ...params: SQLiteVariadicBindParams): Promise<SQLiteRunResult>;\n  public async runAsync(source: string, ...params: any[]): Promise<SQLiteRunResult> {\n    const statement = await this.prepareAsync(source);\n    let result: SQLiteExecuteAsyncResult<unknown>;\n    try {\n      result = await statement.executeAsync(...params);\n    } finally {\n      await statement.finalizeAsync();\n    }\n    return result;\n  }\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareAsync()`](#prepareasyncsource), [`SQLiteStatement.executeAsync()`](#executeasyncparams), [`SQLiteExecuteAsyncResult.getFirstAsync()`](#getfirstasync), and [`SQLiteStatement.finalizeAsync()`](#finalizeasync).\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   */\n  public getFirstAsync<T>(source: string, params: SQLiteBindParams): Promise<T | null>;\n  /**\n   * @hidden\n   */\n  public getFirstAsync<T>(source: string, ...params: SQLiteVariadicBindParams): Promise<T | null>;\n  public async getFirstAsync<T>(source: string, ...params: any[]): Promise<T | null> {\n    const statement = await this.prepareAsync(source);\n    let firstRow: T | null;\n    try {\n      const result = await statement.executeAsync<T>(...params);\n      firstRow = await result.getFirstAsync();\n    } finally {\n      await statement.finalizeAsync();\n    }\n    return firstRow;\n  }\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareAsync()`](#prepareasyncsource), [`SQLiteStatement.executeAsync()`](#executeasyncparams), [`SQLiteExecuteAsyncResult`](#sqliteexecuteasyncresult) `AsyncIterator`, and [`SQLiteStatement.finalizeAsync()`](#finalizeasync).\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   * @returns Rather than returning Promise, this function returns an [`AsyncIterableIterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator). You can use `for await...of` to iterate over the rows from the SQLite query result.\n   */\n  public getEachAsync<T>(source: string, params: SQLiteBindParams): AsyncIterableIterator<T>;\n  /**\n   * @hidden\n   */\n  public getEachAsync<T>(\n    source: string,\n    ...params: SQLiteVariadicBindParams\n  ): AsyncIterableIterator<T>;\n  public async *getEachAsync<T>(source: string, ...params: any[]): AsyncIterableIterator<T> {\n    const statement = await this.prepareAsync(source);\n    try {\n      const result = await statement.executeAsync<T>(...params);\n      for await (const row of result) {\n        yield row;\n      }\n    } finally {\n      await statement.finalizeAsync();\n    }\n  }\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareAsync()`](#prepareasyncsource), [`SQLiteStatement.executeAsync()`](#executeasyncparams), [`SQLiteExecuteAsyncResult.getAllAsync()`](#getallasync), and [`SQLiteStatement.finalizeAsync()`](#finalizeasync).\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   * @example\n   * ```ts\n   * // For unnamed parameters, you pass values in an array.\n   * db.getAllAsync('SELECT * FROM test WHERE intValue = ? AND name = ?', [1, 'Hello']);\n   *\n   * // For unnamed parameters, you pass values in variadic arguments.\n   * db.getAllAsync('SELECT * FROM test WHERE intValue = ? AND name = ?', 1, 'Hello');\n   *\n   * // For named parameters, you should pass values in object.\n   * db.getAllAsync('SELECT * FROM test WHERE intValue = $intValue AND name = $name', { $intValue: 1, $name: 'Hello' });\n   * ```\n   */\n  public getAllAsync<T>(source: string, params: SQLiteBindParams): Promise<T[]>;\n  /**\n   * @hidden\n   */\n  public getAllAsync<T>(source: string, ...params: SQLiteVariadicBindParams): Promise<T[]>;\n  public async getAllAsync<T>(source: string, ...params: any[]): Promise<T[]> {\n    const statement = await this.prepareAsync(source);\n    let allRows;\n    try {\n      const result = await statement.executeAsync<T>(...params);\n      allRows = await result.getAllAsync();\n    } finally {\n      await statement.finalizeAsync();\n    }\n    return allRows;\n  }\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareSync()`](#preparesyncsource), [`SQLiteStatement.executeSync()`](#executesyncparams), and [`SQLiteStatement.finalizeSync()`](#finalizesync).\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   */\n  public runSync(source: string, params: SQLiteBindParams): SQLiteRunResult;\n  /**\n   * @hidden\n   */\n  public runSync(source: string, ...params: SQLiteVariadicBindParams): SQLiteRunResult;\n  public runSync(source: string, ...params: any[]): SQLiteRunResult {\n    const statement = this.prepareSync(source);\n    let result: SQLiteExecuteSyncResult<unknown>;\n    try {\n      result = statement.executeSync(...params);\n    } finally {\n      statement.finalizeSync();\n    }\n    return result;\n  }\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareSync()`](#preparesyncsource), [`SQLiteStatement.executeSync()`](#executesyncparams), [`SQLiteExecuteSyncResult.getFirstSync()`](#getfirstsync), and [`SQLiteStatement.finalizeSync()`](#finalizesync).\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   */\n  public getFirstSync<T>(source: string, params: SQLiteBindParams): T | null;\n  /**\n   * @hidden\n   */\n  public getFirstSync<T>(source: string, ...params: SQLiteVariadicBindParams): T | null;\n  public getFirstSync<T>(source: string, ...params: any[]): T | null {\n    const statement = this.prepareSync(source);\n    let firstRow: T | null;\n    try {\n      const result = statement.executeSync<T>(...params);\n      firstRow = result.getFirstSync();\n    } finally {\n      statement.finalizeSync();\n    }\n    return firstRow;\n  }\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareSync()`](#preparesyncsource), [`SQLiteStatement.executeSync()`](#executesyncparams), [`SQLiteExecuteSyncResult`](#sqliteexecutesyncresult) `Iterator`, and [`SQLiteStatement.finalizeSync()`](#finalizesync).\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   * @returns This function returns an [`IterableIterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator). You can use `for...of` to iterate over the rows from the SQLite query result.\n   */\n  public getEachSync<T>(source: string, params: SQLiteBindParams): IterableIterator<T>;\n  /**\n   * @hidden\n   */\n  public getEachSync<T>(source: string, ...params: SQLiteVariadicBindParams): IterableIterator<T>;\n  public *getEachSync<T>(source: string, ...params: any[]): IterableIterator<T> {\n    const statement = this.prepareSync(source);\n    try {\n      const result = statement.executeSync<T>(...params);\n      for (const row of result) {\n        yield row;\n      }\n    } finally {\n      statement.finalizeSync();\n    }\n  }\n\n  /**\n   * A convenience wrapper around [`SQLiteDatabase.prepareSync()`](#preparesyncsource), [`SQLiteStatement.executeSync()`](#executesyncparams), [`SQLiteExecuteSyncResult.getAllSync()`](#getallsync), and [`SQLiteStatement.finalizeSync()`](#finalizesync).\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   * @param source A string containing the SQL query.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   */\n  public getAllSync<T>(source: string, params: SQLiteBindParams): T[];\n  /**\n   * @hidden\n   */\n  public getAllSync<T>(source: string, ...params: SQLiteVariadicBindParams): T[];\n  public getAllSync<T>(source: string, ...params: any[]): T[] {\n    const statement = this.prepareSync(source);\n    let allRows;\n    try {\n      const result = statement.executeSync<T>(...params);\n      allRows = result.getAllSync();\n    } finally {\n      statement.finalizeSync();\n    }\n    return allRows;\n  }\n\n  //#endregion\n}\n\n/**\n * Open a database.\n *\n * @param databaseName The name of the database file to open.\n * @param options Open options.\n */\nexport async function openDatabaseAsync(\n  databaseName: string,\n  options?: SQLiteOpenOptions\n): Promise<SQLiteDatabase> {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(databaseName, openOptions);\n  await nativeDatabase.initAsync();\n  return new SQLiteDatabase(databaseName, openOptions, nativeDatabase);\n}\n\n/**\n * Open a database.\n *\n * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n *\n * @param databaseName The name of the database file to open.\n * @param options Open options.\n */\nexport function openDatabaseSync(\n  databaseName: string,\n  options?: SQLiteOpenOptions\n): SQLiteDatabase {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(databaseName, openOptions);\n  nativeDatabase.initSync();\n  return new SQLiteDatabase(databaseName, openOptions, nativeDatabase);\n}\n\n/**\n * Given a `Uint8Array` data and [deserialize to memory database](https://sqlite.org/c3ref/deserialize.html).\n *\n * @param serializedData The binary array to deserialize from [`SQLiteDatabase.serializeAsync()`](#serializeasyncdatabasename).\n * @param options Open options.\n */\nexport async function deserializeDatabaseAsync(\n  serializedData: Uint8Array,\n  options?: SQLiteOpenOptions\n): Promise<SQLiteDatabase> {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(':memory:', openOptions, serializedData);\n  await nativeDatabase.initAsync();\n  return new SQLiteDatabase(':memory:', openOptions, nativeDatabase);\n}\n\n/**\n * Given a `Uint8Array` data and [deserialize to memory database](https://sqlite.org/c3ref/deserialize.html).\n *\n * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n *\n * @param serializedData The binary array to deserialize from [`SQLiteDatabase.serializeSync()`](#serializesyncdatabasename)\n * @param options Open options.\n */\nexport function deserializeDatabaseSync(\n  serializedData: Uint8Array,\n  options?: SQLiteOpenOptions\n): SQLiteDatabase {\n  const openOptions = options ?? {};\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(':memory:', openOptions, serializedData);\n  nativeDatabase.initSync();\n  return new SQLiteDatabase(':memory:', openOptions, nativeDatabase);\n}\n\n/**\n * Delete a database file.\n *\n * @param databaseName The name of the database file to delete.\n */\nexport async function deleteDatabaseAsync(databaseName: string): Promise<void> {\n  return await ExpoSQLite.deleteDatabaseAsync(databaseName);\n}\n\n/**\n * Delete a database file.\n *\n * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n *\n * @param databaseName The name of the database file to delete.\n */\nexport function deleteDatabaseSync(databaseName: string): void {\n  return ExpoSQLite.deleteDatabaseSync(databaseName);\n}\n\n/**\n * The event payload for the listener of [`addDatabaseChangeListener`](#sqliteadddatabasechangelistenerlistener)\n */\nexport type DatabaseChangeEvent = {\n  /** The database name. The value would be `main` by default and other database names if you use `ATTACH DATABASE` statement. */\n  databaseName: string;\n\n  /** The absolute file path to the database. */\n  databaseFilePath: string;\n\n  /** The table name. */\n  tableName: string;\n\n  /** The changed row ID. */\n  rowId: number;\n};\n\n/**\n * Add a listener for database changes.\n * > Note: to enable this feature, you must set [`enableChangeListener` to `true`](#sqliteopenoptions) when opening the database.\n *\n * @param listener A function that receives the `databaseName`, `databaseFilePath`, `tableName` and `rowId` of the modified data.\n * @returns A `Subscription` object that you can call `remove()` on when you would like to unsubscribe the listener.\n */\nexport function addDatabaseChangeListener(\n  listener: (event: DatabaseChangeEvent) => void\n): Subscription {\n  return emitter.addListener('onDatabaseChange', listener);\n}\n\n/**\n * A new connection specific used for [`withExclusiveTransactionAsync`](#withexclusivetransactionasynctask).\n * @hidden not going to pull all the database methods to the document.\n */\nclass Transaction extends SQLiteDatabase {\n  public static async createAsync(db: SQLiteDatabase): Promise<Transaction> {\n    const options = { ...db.options, useNewConnection: true };\n    const nativeDatabase = new ExpoSQLite.NativeDatabase(db.databaseName, options);\n    await nativeDatabase.initAsync();\n    return new Transaction(db.databaseName, options, nativeDatabase);\n  }\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAsB,mBAAmB;AAE9D,OAAOC,UAAU,MAAM,kBAAkB;AAEzC,SAKEC,eAAe,QAEV,mBAAmB;AAI1B,MAAMC,OAAO,GAAG,IAAIH,YAAY,CAACC,UAAU,CAAC;AAK5C,OAAM,MAAOG,cAAc;EACzBC,YACkBC,YAAoB,EACpBC,OAA0B,EACzBC,cAA8B;IAF/B,KAAAF,YAAY,GAAZA,YAAY;IACZ,KAAAC,OAAO,GAAPA,OAAO;IACN,KAAAC,cAAc,GAAdA,cAAc;EAC9B;EAKIC,oBAAoBA,CAAA;IACzB,OAAO,IAAI,CAACD,cAAc,CAACC,oBAAoB,EAAE;EACnD;EAKOC,UAAUA,CAAA;IACf,OAAO,IAAI,CAACF,cAAc,CAACE,UAAU,EAAE;EACzC;EAQOC,SAASA,CAACC,MAAc;IAC7B,OAAO,IAAI,CAACJ,cAAc,CAACG,SAAS,CAACC,MAAM,CAAC;EAC9C;EAOOC,cAAcA,CAACP,YAAA,GAAuB,MAAM;IACjD,OAAO,IAAI,CAACE,cAAc,CAACK,cAAc,CAACP,YAAY,CAAC;EACzD;EAOO,MAAMQ,YAAYA,CAACF,MAAc;IACtC,MAAMG,eAAe,GAAG,IAAId,UAAU,CAACe,eAAe,EAAE;IACxD,MAAM,IAAI,CAACR,cAAc,CAACM,YAAY,CAACC,eAAe,EAAEH,MAAM,CAAC;IAC/D,OAAO,IAAIV,eAAe,CAAC,IAAI,CAACM,cAAc,EAAEO,eAAe,CAAC;EAClE;EAyBO,MAAME,oBAAoBA,CAACC,IAAyB;IACzD,IAAI;MACF,MAAM,IAAI,CAACP,SAAS,CAAC,OAAO,CAAC;MAC7B,MAAMO,IAAI,EAAE;MACZ,MAAM,IAAI,CAACP,SAAS,CAAC,QAAQ,CAAC;KAC/B,CAAC,OAAOQ,CAAC,EAAE;MACV,MAAM,IAAI,CAACR,SAAS,CAAC,UAAU,CAAC;MAChC,MAAMQ,CAAC;;EAEX;EAmBO,MAAMC,6BAA6BA,CACxCF,IAAyC;IAEzC,MAAMG,WAAW,GAAG,MAAMC,WAAW,CAACC,WAAW,CAAC,IAAI,CAAC;IACvD,IAAIC,KAAK;IACT,IAAI;MACF,MAAMH,WAAW,CAACV,SAAS,CAAC,OAAO,CAAC;MACpC,MAAMO,IAAI,CAACG,WAAW,CAAC;MACvB,MAAMA,WAAW,CAACV,SAAS,CAAC,QAAQ,CAAC;KACtC,CAAC,OAAOQ,CAAC,EAAE;MACV,MAAME,WAAW,CAACV,SAAS,CAAC,UAAU,CAAC;MACvCa,KAAK,GAAGL,CAAC;KACV,SAAS;MACR,MAAME,WAAW,CAACX,UAAU,EAAE;;IAEhC,IAAIc,KAAK,EAAE;MACT,MAAMA,KAAK;;EAEf;EAKOC,mBAAmBA,CAAA;IACxB,OAAO,IAAI,CAACjB,cAAc,CAACiB,mBAAmB,EAAE;EAClD;EAKOC,SAASA,CAAA;IACd,OAAO,IAAI,CAAClB,cAAc,CAACkB,SAAS,EAAE;EACxC;EAWOC,QAAQA,CAACf,MAAc;IAC5B,OAAO,IAAI,CAACJ,cAAc,CAACmB,QAAQ,CAACf,MAAM,CAAC;EAC7C;EASOgB,aAAaA,CAACtB,YAAA,GAAuB,MAAM;IAChD,OAAO,IAAI,CAACE,cAAc,CAACoB,aAAa,CAACtB,YAAY,CAAC;EACxD;EASOuB,WAAWA,CAACjB,MAAc;IAC/B,MAAMG,eAAe,GAAG,IAAId,UAAU,CAACe,eAAe,EAAE;IACxD,IAAI,CAACR,cAAc,CAACqB,WAAW,CAACd,eAAe,EAAEH,MAAM,CAAC;IACxD,OAAO,IAAIV,eAAe,CAAC,IAAI,CAACM,cAAc,EAAEO,eAAe,CAAC;EAClE;EASOe,mBAAmBA,CAACZ,IAAgB;IACzC,IAAI;MACF,IAAI,CAACS,QAAQ,CAAC,OAAO,CAAC;MACtBT,IAAI,EAAE;MACN,IAAI,CAACS,QAAQ,CAAC,QAAQ,CAAC;KACxB,CAAC,OAAOR,CAAC,EAAE;MACV,IAAI,CAACQ,QAAQ,CAAC,UAAU,CAAC;MACzB,MAAMR,CAAC;;EAEX;EAeO,MAAMY,QAAQA,CAACnB,MAAc,EAAE,GAAGoB,MAAa;IACpD,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACnB,YAAY,CAACF,MAAM,CAAC;IACjD,IAAIsB,MAAyC;IAC7C,IAAI;MACFA,MAAM,GAAG,MAAMD,SAAS,CAACE,YAAY,CAAC,GAAGH,MAAM,CAAC;KACjD,SAAS;MACR,MAAMC,SAAS,CAACG,aAAa,EAAE;;IAEjC,OAAOF,MAAM;EACf;EAYO,MAAMG,aAAaA,CAAIzB,MAAc,EAAE,GAAGoB,MAAa;IAC5D,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACnB,YAAY,CAACF,MAAM,CAAC;IACjD,IAAI0B,QAAkB;IACtB,IAAI;MACF,MAAMJ,MAAM,GAAG,MAAMD,SAAS,CAACE,YAAY,CAAI,GAAGH,MAAM,CAAC;MACzDM,QAAQ,GAAG,MAAMJ,MAAM,CAACG,aAAa,EAAE;KACxC,SAAS;MACR,MAAMJ,SAAS,CAACG,aAAa,EAAE;;IAEjC,OAAOE,QAAQ;EACjB;EAgBO,OAAOC,YAAYA,CAAI3B,MAAc,EAAE,GAAGoB,MAAa;IAC5D,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACnB,YAAY,CAACF,MAAM,CAAC;IACjD,IAAI;MACF,MAAMsB,MAAM,GAAG,MAAMD,SAAS,CAACE,YAAY,CAAI,GAAGH,MAAM,CAAC;MACzD,WAAW,MAAMQ,GAAG,IAAIN,MAAM,EAAE;QAC9B,MAAMM,GAAG;;KAEZ,SAAS;MACR,MAAMP,SAAS,CAACG,aAAa,EAAE;;EAEnC;EAuBO,MAAMK,WAAWA,CAAI7B,MAAc,EAAE,GAAGoB,MAAa;IAC1D,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACnB,YAAY,CAACF,MAAM,CAAC;IACjD,IAAI8B,OAAO;IACX,IAAI;MACF,MAAMR,MAAM,GAAG,MAAMD,SAAS,CAACE,YAAY,CAAI,GAAGH,MAAM,CAAC;MACzDU,OAAO,GAAG,MAAMR,MAAM,CAACO,WAAW,EAAE;KACrC,SAAS;MACR,MAAMR,SAAS,CAACG,aAAa,EAAE;;IAEjC,OAAOM,OAAO;EAChB;EAaOC,OAAOA,CAAC/B,MAAc,EAAE,GAAGoB,MAAa;IAC7C,MAAMC,SAAS,GAAG,IAAI,CAACJ,WAAW,CAACjB,MAAM,CAAC;IAC1C,IAAIsB,MAAwC;IAC5C,IAAI;MACFA,MAAM,GAAGD,SAAS,CAACW,WAAW,CAAC,GAAGZ,MAAM,CAAC;KAC1C,SAAS;MACRC,SAAS,CAACY,YAAY,EAAE;;IAE1B,OAAOX,MAAM;EACf;EAaOY,YAAYA,CAAIlC,MAAc,EAAE,GAAGoB,MAAa;IACrD,MAAMC,SAAS,GAAG,IAAI,CAACJ,WAAW,CAACjB,MAAM,CAAC;IAC1C,IAAI0B,QAAkB;IACtB,IAAI;MACF,MAAMJ,MAAM,GAAGD,SAAS,CAACW,WAAW,CAAI,GAAGZ,MAAM,CAAC;MAClDM,QAAQ,GAAGJ,MAAM,CAACY,YAAY,EAAE;KACjC,SAAS;MACRb,SAAS,CAACY,YAAY,EAAE;;IAE1B,OAAOP,QAAQ;EACjB;EAcO,CAACS,WAAWA,CAAInC,MAAc,EAAE,GAAGoB,MAAa;IACrD,MAAMC,SAAS,GAAG,IAAI,CAACJ,WAAW,CAACjB,MAAM,CAAC;IAC1C,IAAI;MACF,MAAMsB,MAAM,GAAGD,SAAS,CAACW,WAAW,CAAI,GAAGZ,MAAM,CAAC;MAClD,KAAK,MAAMQ,GAAG,IAAIN,MAAM,EAAE;QACxB,MAAMM,GAAG;;KAEZ,SAAS;MACRP,SAAS,CAACY,YAAY,EAAE;;EAE5B;EAaOG,UAAUA,CAAIpC,MAAc,EAAE,GAAGoB,MAAa;IACnD,MAAMC,SAAS,GAAG,IAAI,CAACJ,WAAW,CAACjB,MAAM,CAAC;IAC1C,IAAI8B,OAAO;IACX,IAAI;MACF,MAAMR,MAAM,GAAGD,SAAS,CAACW,WAAW,CAAI,GAAGZ,MAAM,CAAC;MAClDU,OAAO,GAAGR,MAAM,CAACc,UAAU,EAAE;KAC9B,SAAS;MACRf,SAAS,CAACY,YAAY,EAAE;;IAE1B,OAAOH,OAAO;EAChB;;AAWF,OAAO,eAAeO,iBAAiBA,CACrC3C,YAAoB,EACpBC,OAA2B;EAE3B,MAAM2C,WAAW,GAAG3C,OAAO,IAAI,EAAE;EACjC,MAAMC,cAAc,GAAG,IAAIP,UAAU,CAACkD,cAAc,CAAC7C,YAAY,EAAE4C,WAAW,CAAC;EAC/E,MAAM1C,cAAc,CAAC4C,SAAS,EAAE;EAChC,OAAO,IAAIhD,cAAc,CAACE,YAAY,EAAE4C,WAAW,EAAE1C,cAAc,CAAC;AACtE;AAUA,OAAM,SAAU6C,gBAAgBA,CAC9B/C,YAAoB,EACpBC,OAA2B;EAE3B,MAAM2C,WAAW,GAAG3C,OAAO,IAAI,EAAE;EACjC,MAAMC,cAAc,GAAG,IAAIP,UAAU,CAACkD,cAAc,CAAC7C,YAAY,EAAE4C,WAAW,CAAC;EAC/E1C,cAAc,CAAC8C,QAAQ,EAAE;EACzB,OAAO,IAAIlD,cAAc,CAACE,YAAY,EAAE4C,WAAW,EAAE1C,cAAc,CAAC;AACtE;AAQA,OAAO,eAAe+C,wBAAwBA,CAC5CC,cAA0B,EAC1BjD,OAA2B;EAE3B,MAAM2C,WAAW,GAAG3C,OAAO,IAAI,EAAE;EACjC,MAAMC,cAAc,GAAG,IAAIP,UAAU,CAACkD,cAAc,CAAC,UAAU,EAAED,WAAW,EAAEM,cAAc,CAAC;EAC7F,MAAMhD,cAAc,CAAC4C,SAAS,EAAE;EAChC,OAAO,IAAIhD,cAAc,CAAC,UAAU,EAAE8C,WAAW,EAAE1C,cAAc,CAAC;AACpE;AAUA,OAAM,SAAUiD,uBAAuBA,CACrCD,cAA0B,EAC1BjD,OAA2B;EAE3B,MAAM2C,WAAW,GAAG3C,OAAO,IAAI,EAAE;EACjC,MAAMC,cAAc,GAAG,IAAIP,UAAU,CAACkD,cAAc,CAAC,UAAU,EAAED,WAAW,EAAEM,cAAc,CAAC;EAC7FhD,cAAc,CAAC8C,QAAQ,EAAE;EACzB,OAAO,IAAIlD,cAAc,CAAC,UAAU,EAAE8C,WAAW,EAAE1C,cAAc,CAAC;AACpE;AAOA,OAAO,eAAekD,mBAAmBA,CAACpD,YAAoB;EAC5D,OAAO,MAAML,UAAU,CAACyD,mBAAmB,CAACpD,YAAY,CAAC;AAC3D;AASA,OAAM,SAAUqD,kBAAkBA,CAACrD,YAAoB;EACrD,OAAOL,UAAU,CAAC0D,kBAAkB,CAACrD,YAAY,CAAC;AACpD;AA0BA,OAAM,SAAUsD,yBAAyBA,CACvCC,QAA8C;EAE9C,OAAO1D,OAAO,CAAC2D,WAAW,CAAC,kBAAkB,EAAED,QAAQ,CAAC;AAC1D;AAMA,MAAMvC,WAAY,SAAQlB,cAAc;EAC/B,aAAamB,WAAWA,CAACwC,EAAkB;IAChD,MAAMxD,OAAO,GAAAyD,MAAA,CAAAC,MAAA,KAAQF,EAAE,CAACxD,OAAO;MAAE2D,gBAAgB,EAAE;IAAI,EAAE;IACzD,MAAM1D,cAAc,GAAG,IAAIP,UAAU,CAACkD,cAAc,CAACY,EAAE,CAACzD,YAAY,EAAEC,OAAO,CAAC;IAC9E,MAAMC,cAAc,CAAC4C,SAAS,EAAE;IAChC,OAAO,IAAI9B,WAAW,CAACyC,EAAE,CAACzD,YAAY,EAAEC,OAAO,EAAEC,cAAc,CAAC;EAClE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}